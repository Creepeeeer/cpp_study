**继承的语法**:

```c++
class a :public b
```

表示a继承了b



**protected：**

基类类内和派生类类内可以访问，但是类外不能访问

### 类的继承方式：

**public,private,protected**,不写默认private

**public:**父类public是public ，父类protected是protected 父类private不可访问

**protected:**父类public是protected ，父类protected是protected 父类private不可访问

**private:**父类public是private ，父类protected是private 父类private不可访问



可以修改基类 private和protected成员变量在派生类里的访问权限

```c++
class A{
public:
	int a;
protected:
	int b;
private:
	int c;//不可使用using 类::改变权限

};
class B :public A {
public:
	using A::b;//将A中保护b变成B中公有
protected:
private:
	using A::a;//将A中公有a变成B中私有

};
```



### 继承的对象模型：

- 创建派生类对象的时候，先调用基类的构造函数再调用派生类的构造函数
- 销毁派生类对象的时候，先调用派生类析构函数再调用基类的析构函数
- 但是创建派生类对象的时候只会分配一次空间，基类的this和派生类的this指向同一块内存



**可以用初始化列表指明要使用的基类构造函数**

```c++
class A {
private:
	int a, b;
public:
	A():a(0),b(0){}
	A(int a,int b):a(a),b(b){}
	A(const A& x) :a(x.a), b(x.b){}
};
class B:public A{
private:
	int c;
public:
	B():A(),c(0){}
	B(int a,int b,int c):A(a,b),c(c){}
	B(const A& x, int c) :A(x), c(c) {}//并不等价于B的拷贝构造函数
};
```



### 名字遮蔽和类作用域

**如果派生类的成员变量和成员函数和基类重名，那么在派生类中使用成员变量和成员函数时将使用派生类里的**

```c++
class A {
public:
	int a = 10;
	void func() {
		cout << "调用基类" << endl;
	}
};
class B:public A{
public:
	int a = 20;
	void func() {
		cout << "调用派生类" << endl;
	}
};
int main() {
	B b;
	cout << b.a << endl;
	b.func();
}
//20
//调用派生类
```



**基类和派生类里的同名函数不会重载，当派生类里有同名函数时将会遮蔽基类里的同名函数**

```c++
class A {
public:
	void func() {
		cout << "调用基类" << endl;
	}
	void func(int a) {
		cout << "调用基类" <<' '<<a<< endl;
	}
};
class B:public A{
public:
	void func() {
		cout << "调用派生类" << endl;
	}
};
int main() {
	B b;
	b.func(1);
}
//现在会报错
```



### 类的作用域

1. 类是一种作用域 ,每个类都有自己的作用域，在这个作用域内定义成员
1. 在类的作用域外，普通成员只能通过对象来访问，静态成员可以通过对象和类访问
1. 当存在继承关系的时候，基类作用域嵌套在派生类作用域里，先在派生类作用域找->如果没找到然后在基类作用域找
1. 如果成员前面加类名和域作用符号那么就可以直接使用该作用域成员

```c++
class A {
public:
	int a = 10;
	void func() {
		cout << "调用A" << endl;
	}
};
class B:public A {
public:
	int a = 20;
	void func() {
		cout << "调用B" << endl;
	}
};
class C :public B{
public:
	int a = 30;
	void func() {
		cout << "调用C" << endl;
	}
};

int main() {
	C c;
	cout << c.C::a << endl;
	cout << c.C::B::a << endl;
	cout << c.C::B::A::a << endl;
	cout << c.a << endl;
	cout << c.B::a << endl;
	cout << c.B::A::a << endl;
	c.func();
	c.B::func();
	c.B::A::func();
}
30
20
10
30
20
10
调用C
调用B
调用A
```



### 继承的特殊关系

1. 可以把派生类对象赋值给基类（包括私有成员),但是会舍弃非基类成员

   ```c++
   class A {
   public:
   	int a=0 ;
   	void set_b(int b) {
   		A::b = b;
   	}
   	void print() {
   		cout << a << ' ' << b << endl;
   	}
   private:
   	int b=0;
   };
   
   class B :public A {
   public:
   	int c;
   };
   int main() {
   	A a;
   	B b;
   	b.a = 1;
   	b.set_b(2);
   	b.c = 3;
   	a.print();
   	a = b;
   	a.print();
   }
   0 0
   1 2
   ```

2. 基类指针可以在不显性转化的情况下指向派生类对象
3. 基类引用可以在不显性转化的情况下指向派生类对象

```c++
class A {
public:
	int a=1, b=2;
};
class B :public A {
public:
	int c=1;
};
int main() {
	B b;
	A* a = &b;
	A& a = b;
}
```



### 多继承和虚继承

**多继承：**一个派生类继承了多个基类

```c++
class 派生类名 :继承方式1 类名1,继承方式2 类名2
```

**菱形继承：**

```c++
class A {
public: int a=1;
};
class B :public A {
};
class C :public A {

};
class D :public B, public C {
	
};
int main() {
	D a;
	a.B::a;
	a.C::a;
    //如果不加作用域符会报错
}
```

菱形继承存在两个问题：数据冗余和名称的二义性：此时D有两个a

**虚继承：**解决了上面的问题，此时虚基类只在派生类里构造一次

```c++
class A {
public: int a=1;
};
class B :virtual public A {
};
class C :virtual public A {

};
class D :public B, public C {
	
};
int main() {
	D a;
	cout << &a.B::a << endl;
	cout << &a.C::a << endl;
}
```



## 类的多态

**要用public继承**

1. 基类指针只能调用基类的成员函数，不能调用派生类的成员函数

2. 但如果在基类的成员函数前面加virtual关键字，那么此时这个函数就是虚函数，那么此时基类指针指向派生类对象的时候就可以访问派生类里同名成员函数，通过同名函数就可以访问派生类对象的成员变量

3. 多态：基类指针指向基类时就使用基类的成员函数和数据，指向派生类对象时就使用派生类的成员函数和变量

4. 用基类引用也可以

   ```c++
   	class A {
   	public:
   		int a = 1;
   		virtual void show() {
   			cout << a << endl;
   		}
   	};
   	class B:public A{
   		int b=2;
   	public:
   		void show() {
   			cout << a << ' ' << b << endl;
   		}
   	};
   	int main() {
   		B b;
   		A* pa = &b;
   		pa->show();
   		A& a = b;
   		a.show();
   	}
   ```

   5. 在派生类重写基类的虚函数的时候可以加override关键字，让编译器帮你检查参数列表函数名等是否一样

   ```c++
   class A {
   public:
   	virtual void func() = 0;
   };
   class B :public A {
   public:
   	void func()override {
   		cout << 1 << endl;
   	}
   };
   ```

   

**注意：**

1. 只需要在基类函数声明的时候要加virtual关键字，函数定义的时候不能加
2. 如果想发生多态，基类的虚函数必须和派生类里重定义的函数函数名相同，参数也要一样

```c++
	class A {
	public:
		int a = 1;
		virtual void show() {
			cout << 1 << endl;
		}
		virtual void show(int i) {
			cout << 2 << endl;
		}
	};
	class B:public A{
		int b=2;
	public:
		void show() {
			cout << "调用没有参数的" << endl;
		}
		void show(int i) {
			cout << "调用有一个参数的" << endl;
		}
	};
	int main() {
		B b;
		A* a = &b;
		a->show();
		a->show(1);
	}
//调用没有参数的
//调用有一个参数的
```

3. 在派生类重定义了虚函数的情况下，如果想调用基类的虚函数，可以加类名和域解析符

```c++
a->A::show();
```

### 多态的应用场景

基类的虚函数实现基础功能，派生类定义虚函数来拓展功能



### 如何析构派生类

**派生类调用析构函数的时候会自动调用基类的析构函数**

但用基类指针指向派生类对象的时候不会析构派生类对象

```c++
class A{
public:
	A() {
		cout << "A构造" << endl;
	}
	~A() {
		cout << "A析构" << endl;
	}
};
class B:public A {
public:
	B() {
		cout << "B构造" << endl;
	}
	~B() {
		cout << "B析构" << endl;
	}
};
int main() {
	A* a = new B;
	delete a;
}
//A构造
B构造
A析构
```

**解决方法：把基类的析构函数设置成虚函数**

**无论基类需不需要析构函数，基类都尽量写一个空的虚析构函数**，如果用基类指针指向派生类对象的时候，如果不这么写会出现派生类对象内存无法释放

构造函数，析构函数，赋值运算符，友元函数不能继承



### 纯虚函数和抽象类

**纯虚函数：**基类中不能给虚函数给出明确定义，把具体功能留给派生类实现

**语法：**virtual 返回值类型 函数名（参数）=0;

**抽象类：**如果一个基类里有纯虚函数那么这个类就是抽象类

```c++
class A{
public:
	virtual void func() = 0;
};
int main() {
	A a;
}
//此时A是抽象类不能实例化
//报错：不允许使用抽象类类型 "A" 的对象:
```

```c++
class A{
public:
	virtual void func() = 0;
};
class B :public A {
};
int main() {
	B b;
}
//如果派生类里没有实现的纯虚函数也不能实例化
//报错:不允许使用抽象类类型 "B" 的对象:
```

**可以创建抽象类指针指向派生类对象**

纯虚函数=0后面也可以跟上代码实现，可以选择有也可以选择没有，**但是纯虚析构函数后面必须有代码实现**

```c++
virtual void func() = 0 {
	cout << 1 << endl;
}
```



### 运行阶段类型识别 dynamic_cast

**使用前提：基类必须要有虚函数**

**基类指针可以直接指向派生类对象，但派生类指针不能直接指向基类**

```c++
A* a = new C;
auto it = dynamic_cast<C*>(a);
```

也可以用于判断这个指针是不是这个类的

```c++
A* a = new C;
if (dynamic_cast<B*>(a) != nullptr) {
	cout << 1 << endl;
}
```



### typeid运算符和type_info类

**typeid运算符用于获取数据类型,返回值是type_info类**

```c++
typeid(int)//可用于数据类型
typeid(n+m)//也可用于表达式
```

**typeinfo重载了==和!=用于判断两个类型是不是相等的**

```c++
cout << (typeid(1 + 2)==typeid(int));
```

**typeinfo.name()返回一个数据类型的字符串**

```c++
cout<<typeid(int).name()<<endl;
//int 和编译器有关
```

