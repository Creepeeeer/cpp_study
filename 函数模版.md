## 函数模版

```c++
template<typename T>
void Swap(T&a, T&b) {
	T tmp = a;
	a = b;
	b = tmp;
}
```

此时template 这一行的作用域只为离他最近的下一行函数

调用的时候

```c++
int a=1,b=2;
Swap(1,2);//隐形直接调用
Swap<int>(1,2)//也可以这么写
```



可以接收有多个通用数据类型的参数

```c++
template<typename T1,typename T2>
```

函数模版可以有非通用数据类型的参数

```c++
template<typename T1,typename T2>
void func(T1 a,T2 b,int c){}
```



### 函数模版的特化

**是“专门为某个类型写一个特别版本的函数”，也可以有多个**

首先你要先有一个函数模版，然后在这个函数模版的下面加上函数模版的特化

```c++
template<typename T>//函数模版
void Swap(T& a, T& b) {
	T c = a;
	a = b;
	b = c;
}
template <>
void Swap(int& a, int& b) {//实例化，只要把上面函数模版对应的T位置写成相同的具体的变量类型
	int c = a;
	a = b;
	b = c;
}
//可以有多个特化的函数模版
```

Swap（a,b) **函数使用的优先级： 普通函数>具体化>常规模版**

Swap<>(a,b) **函数使用的优先级：具体化>常规模版**



### 函数模版显性实例化

是“让编译器生成某个类型的模板函数，但内容不变”，不会产生新的代码，只是让编译器提前生成模板实例

```c++
template void Swap<int>(int& a, int& b);
```



### 函数模版分文件编写

函数模版只是函数的描述，没有实体，创建函数模版的代码放在头文件.h中

函数模版的具体化有实体，编译的原理和普通函数一样，所以声明放在头文件.h中，定义放在源文件.cpp中



## 类模版

```c++
template <class T>//也可以是之前的typename
class AA{
public:
	T a;
	AA(T aa):a(aa){}
	AA(){}
};
//main
	AA<int>a(3);
	cout << a.a << endl;
//此时创建类对象的时候必须指明模版的类型
```



模版类的成员函数也可以在类外定义

```c++
template <class T>
class AA{
public:
	T a;
	AA(T aa):a(aa){}
	AA(){}
	void show(T b);
};
template <class T>
void AA<T>::show(T b) {
	cout << a + b << endl;
}
```

可以用new创建模版类对象

```c++
AA<int>* a = new AA<int>(2);//后面跟着的参数位配合构造函数
```

类模版可	以有非通用类型参数，这个参数也可以有缺省值，这个参数必须是常量表达式，并且在模版中不能修改这个参数的值

```c++
template <class T,int b=5>
class Array {
private:
	T a[b + 1];
public:
	Array() { mement(a, 0, sizeof(a)); }
	~Array(){}
	int& operator[](int ii) { return a[ii]; }
	const int& operator[](int ii)const { return a[ii]; }
};
Array<int, 3>a; 
```

