### unique_ptr

**独占所有权：同一时刻只有一个指针能拥有这块内存，不能拷贝只能移动**

**创建**：使用**make_unique**

```c++
	unique_ptr<int>ptr = make_unique<int>(2);
	unique_ptr<int[]>ptr = make_unique<int[]>(10);//数组长度为10，初始值为0
	struct A {
		int a, b;
		A(int a, int b) :a(a), b(b){}
	};
	unique_ptr<A>ptr2 = make_unique<A>(1, 2);
```

**转交所有权：move**

```c++
unique_ptr<int>ptr = make_unique<int>(2);
unique_ptr<int>ptr2 = move(ptr);
```

**不允许赋值**

```c++
unique_ptr<int>ptr2 = ptr;
unique_ptr<int>ptr2(ptr);//都报错 因为他的拷贝构造函数被删除了
```

**常用函数**

```c++
unique_ptr<int>p = make_unique<int>(3);
p.get();//获取原始指针
int* p2 = p.release();//p放弃对象的管理，把权限给p2,p2需要自己手动释放这块内存
//p.reset 释放原来指向的那块内存 括号里可以放一个原始指针让这个unique_ptr再指向这个原始指针
p.reset(new int(20));
int* a;
p.reset(a);
p.reset();
```



### shared_ptr

**创建：使用make_shared**

```c++
shared_ptr<int>ptr = make_shared<int>(1);
```

**支持赋值 赋值会使use_count++**

```c++
shared_ptr<int>ptr2 = ptr;
ptr.use_count()//返回当前这块内存被多少个shared_ptr指向

```



### weak_ptr

**使用场景：两个结构体有互相的share_ptr 那么use_count 永远不会为0那么就永远不会析构了**

```c++
struct B;
struct A;
struct A {
	shared_ptr<B>ptr;
	~A() {
		cout << 1 << endl;
	}
};
struct B {
	shared_ptr<A>ptr;
	~B() {
		cout << 2 << endl;
	}
};
int main() {
	shared_ptr<A>pa = make_shared<A>();
	shared_ptr<B>pb = make_shared<B>();
	pa->ptr = pb;
	pb->ptr = pa;
}
//此时A和B的析构函数都不会调用了
//解决方案 将一端的shared_ptr变成weak_ptr
```

 **weak_ptr用一个shared_ptr来初始化，但是不会增加shared_ptr的use_count**

```c++
weak_ptr<int>p;
shared_ptr<int>p2 = make_shared<int>(2);
p = p2;
cout << p2.use_count() << endl;
```

**weak_ptr不能直接访问指向的那一块内存，即不可以*访问并且它也没有.get函数**

```c++
p.expired();//返回值为bool 如果p指向的shared_ptr的引用计数为0返回true
shared_ptr<int>p3 = p.lock();//返回值为shared_ptr 返回的是weak_ptr指向的那个shared_ptr 会使那个shared_ptr的use_count++ 
//但是作用域结束之后p3会自动销毁use_count--
```

