## 函数模版

```c++
template<typename T>
void Swap(T&a, T&b) {
	T tmp = a;
	a = b;
	b = tmp;
}
```

此时template 这一行的作用域只为离他最近的下一行函数

调用的时候

```c++
int a=1,b=2;
Swap(1,2);//隐形直接调用
Swap<int>(1,2)//也可以这么写
```



可以接收有多个通用数据类型的参数

```c++
template<typename T1,typename T2>
```

函数模版可以有非通用数据类型的参数

```c++
template<typename T1,typename T2>
void func(T1 a,T2 b,int c){}
```



### 函数模版的特化

**是“专门为某个类型写一个特别版本的函数”，也可以有多个**

首先你要先有一个函数模版，然后在这个函数模版的下面加上函数模版的特化

```c++
template<typename T>//函数模版
void Swap(T& a, T& b) {
	T c = a;
	a = b;
	b = c;
}
template <>
void Swap(int& a, int& b) {//实例化，只要把上面函数模版对应的T位置写成相同的具体的变量类型
	int c = a;
	a = b;
	b = c;
}
//可以有多个特化的函数模版
```

Swap（a,b) **函数使用的优先级： 普通函数>具体化>常规模版**

Swap<>(a,b) **函数使用的优先级：具体化>常规模版**



### 函数模版显性实例化

是“让编译器生成某个类型的模板函数，但内容不变”，不会产生新的代码，只是让编译器提前生成模板实例

```c++
template void Swap<int>(int& a, int& b);
```



### 函数模版分文件编写

函数模版定义和声明放头文件

函数模版特化声明放头文件，定义放源文件

函数模版显性实例化的声明放源文件



## 类模版

```c++
template <class T>//也可以是之前的typename
class AA{
public:
	T a;
	AA(T aa):a(aa){}
	AA(){}
};
//main
	AA<int>a(3);
	cout << a.a << endl;
//此时创建类对象的时候必须指明模版的类型
```



模版类的成员函数也可以在类外定义

```c++
template <class T>
class AA{
public:
	T a;
	AA(T aa):a(aa){}
	AA(){}
	void show(T b);
};
template <class T>
void AA<T>::show(T b) {
	cout << a + b << endl;
}
```

可以用new创建模版类对象

```c++
AA<int>* a = new AA<int>(2);//后面跟着的参数位配合构造函数
```

类模版可	以有非通用类型参数，这个参数也可以有缺省值，这个参数必须是常量表达式，并且在模版中不能修改这个参数的值

```c++
template <class T,int b=5>
class Array {
private:
	T a[b + 1];
public:
	Array() { memset(a, 0, sizeof(a)); }
	~Array(){}
	T& operator[](int ii) { return a[ii]; }
	const T& operator[](int ii)const { return a[ii]; }
};
Array<int, 3>a; 
```



## 模版自定义比较规则

- 重载operator <
- 传入比较器类型

```c++
template<typename T,typename Compare=less<T>>
class A {
	Compare comp;//比较器对象
	//a<b就直接写成
	//comp(a, b);
	bool equal(const T& a, const T& b) const{
		return !comp(a, b) && !comp(b, a);
	}

};

	A<int> a;//升序
	A<int, greater<int>>b;
	struct node {
		int a, b;
	};
	struct cmp {
		bool operator()(const node& a, const node& b)const {
			return a.a < b.a;
		}
	};
	A<node, cmp>c;
```

- lambda表达式

```c++
此时需要显性的定义接受比较器的构造函数
class A {
	Compare comp;//比较器对象
	//a<b就直接写成
	//comp(a, b);
	bool equal(const T& a, const T& b) const{
		return !comp(a, b) && !comp(b, a);
	}
public:
	 explicit A(Compare c):comp(c){}
	 A() = default;
};
	struct node {
		int a, b;
	};
	auto cmp = [](const node& x, const node& y) {
		return x.a < y.a;
		};
	A<node, decltype(cmp)>a(cmp);
```





### extern template

假如在一个.h文件中定义了一个模版，在两个.cpp里都调用了这个模版，两份cpp里都会生成实例化代码（非常冗余）

**解决方法**

只在一个.cpp里显性实例化，然后其他.cpp的就只会引用外部的实现不会自己实现

.h

```c++
template<typename T>
void f(T& a) {
	cout << 1 << endl;
}
extern template void f<int>(int&);//显性实例化声明放在头文件，所有使用者不再隐形实例化f<int>
```



f.cpp(**显性实例化定义在一个源文件中，集中生成这份代码**)

```c++
template void f<int>(int&);
```

