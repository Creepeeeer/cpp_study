**头文件**

```c++
#include<fstream>
//主要实现靠三个类
ifstream//输入文件流
ofstream//输出文件流
fstream//读写	
```

## 文本文件

### 打开文件

**可以使用默认的构造函数**

```c++
string s = "an.txt";
char s[] = "an.txt";
ifstream is("an.txt");
//使用char*数组和string也都支持
```

**也可以用.open函数**

```c++
ofstream os;
os.open("an.txt");
```

**文件名一般用全路径**

```c++
"E:\code\vs\Project1\Project1" //错误，因为\+字母是转义字符
R"(E:\code\vs\Project1\Project1)"//原始字面量，c++11标准
"E:\\code\\vs\\Project1\\Project1"//转义字符
"E:/code/vs/Project1/Project1"//把斜线反过来写
"code/vs/Project1/Project1"//linux采用的方法
```



**文件打开的方式**

输出流ofstream

```c++
ios::out //缺省值，截断文件内容
ios::trunc //会覆盖原文件内容
ios::ate//打开时会将指针移动在文章的结尾，后面移动指针后在你指针的后面写内容
ios::app//只在文件末尾追加文件，但无论怎么移动指针永远在文章的结尾写内容
ofstream os;
os.open(R"(E:\code\vs\Project1\Project1\an.txt)",ios::app);
os << "111";
```

**如果打开文件不存在就创建它**

输入流ifstream

```c++
iOS::in
```

**如果打开文件不存在则打开失败**

**判断文件打开是否成功**

```c++
if (!os.is_open()) {
//失败原因：目录不存在，磁盘空间已满，没有权限
}
```

### 写入文件

```c++
	ofstream os;
	os.open(R"(E:\code\vs\Project1\Project1\an.txt)",ios::app);
	os << 1 << ' ' << 2 << endl;
```



### 读取文件

```c++
	ifstream is;
	is.open(R"(E:\code\vs\Project1\Project1\an.txt)", ios::in);
```

方法1(读整行)

```c++
	string s;
	getline(is, s);//读取一行
	while (getline(is, s)) {
		cout << s << endl;//完全读取
	}
```

方法2：（读到空格换行停止）

```c++
is>>s;
```



## 二进制文件

### 打开文件

此时文件的打开要以二进制文件方式打开

ios::binary(有多种打开方式中间用|)

```c++
os.open(R"(E:\code\vs\Project1\Project1\an.txt)",ios::out|ios::binary);
```



### 写入文件

**要使用ofstream的write函数**

```c++
	struct node {
		int a;
		char b[20];
		double c;
	};
	node a = { 1,"aa",3.0 };
	os.write((const char*)&a, sizeof(a));//这里必须强制转化为const char*
```

### 读入文件

要用ifstream的**read**函数

```c++
ifstream fin;
fin.open(R"(E:\code\vs\Project1\Project1\an1.dat)", ios::in | ios::binary);
node b;
fin.read((char*)&b, sizeof(b));
```



**ps:write,read只能直接读写内置类型(int,double,char[])和struct，指针也不行**

### **操作文本文件和二进制文件的一些细节**

- windows平台下，文本文件的换行标志是"\r\n"
- linux平台下换行标志是"\n"
- windows平台下如果在以文本文件打开文件时，写入数据时"\n"会被转化成"\r\n";读取的时候又会转化成"\n";如果以二进制方式读入和写入文件时不会转化
- 以文本方式读取文件的时候遇到换行符停止，读入的内容没有换行符。以二进制方式读取的时候遇到换行符不会停止，读入的内容中右换行符



**在实际开发中**

- 以文本模式打开文本文件，用行方式操作它
- 以二进制方式打开二进制文件，用数据块的方法操作它





## 文件的随机存取



### 获取文件位置指针

ofstream 中成员函数tellp()，ifstream 中成员函数tellg() fstream两个都有，但其实两个指针是一个

**app模式下，tellp一开始返回值也是0,但是只要有内容写入他就会移到最后**



### 移动文件位置指针

ofstream中成员函数seekp()，ifstream中成员函数seekg()

有三个枚举类型

```c++
ios::beg(开头)，ios::cur(当前位置)，ios::end (结尾)
```

 

**有两个重载版本**

```c++
fin.seekg(128);//把文件指针移到第128字节
fin.seekg(ios::beg)//把文件指针移到文件的开始
fin.seekg(30,ios::beg)//从文件开始的位置往后移动30个字节
fin.seekg(-5,ios::cur)//从当前位置往前移5个字节
```





## 文件缓冲区和流状态

**缓冲区**

- 在c++中，每打开一个文件，系统就会为它分配缓冲区。不同的流，缓冲区是独立的

**unitbuf**

```c++
fout<<unitbuf //设置fout输出流，每次操作之后自动刷新缓冲区
```

**nounitbuf**

```c++
fout<<nounitbuf//让fout回到缺省的缓冲方式
```



**流状态**

**流状态有三个：eofbit,badbit，failbit**

**eofbit(只对输入流有意义）**

```c++
fin.eof()==true //已到达文章的文件末尾
```

**badbit：无法诊断的失败破坏流**

```c++
.bad()//成员函数来检查是否设置了badbit
```

**failbit:输入流未能读取预期的字符，或者文件到达了末尾**

```c++
.fail()
```

