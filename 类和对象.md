```c++
class A {
private:
	size_t size=0;
	int* ptr=nullptr;
public:
	A() = default;//使用默认构造函数
	explicit A(size_t siz):size(siz),ptr(siz?new int[siz]:nullptr){}
	~A() {
		delete[]ptr;
	}
	A(const A& x):size(x.size),ptr(x.size?new int [x.size]:nullptr) {//拷贝构造注意要深拷贝
		for (int i = 0; i < x.size; i++) {
			ptr[i] = x.ptr[i];
		}
	}
	A& operator=(const A& x) {//拷贝赋值函数
		if (this == &x)return *this;
		A tmp(x);
		swap(size, tmp.size);
		swap(ptr, tmp.ptr);
		return *this;
	}
	A(A&& x)noexcept:size(x.size),ptr(x.ptr){//移动构造函数 相当于传了个右值进来，要把它的资源给偷了
		x.size = 0;//移动构造尽量noexcept，比如vector扩容的时候选择move不会再copy一份
		x.ptr = nullptr;
	}
	A& operator=(A&& x) noexcept{
		if (&x == this)return *this;
		delete[]ptr;
		size = x.size;
		ptr = x.ptr;
		x.size = 0;
		x.ptr = nullptr;
		return *this;
	}
};
```



### **构造函数**

```c++
	A a;
	A a(10);
	A a{ 10 };
	A a = A(20);
```



### **拷贝构造函数**

```c++
	A a;
	A b = a;
	A b(a);
	void func(A x){}
	func(a)//函数传左值
```



### **拷贝赋值函数**（两个变量都声明过）

```c++
A a,b;
b=a;
```



### **移动构造函数**

```c++
A a(20);
A b=move(a);
A c=A(20);//通常是调用直接调用构造函数的 如果构造函数被delete了就会调用移动构造函数
void func(A x){}
	func(move(a))//函数传左值
```



### **移动赋值函数**

```c++
A a,b;
b=move(a);
```



### 初始化列表

必须使用初始化列表的场景：

- 有const成员变量
- 有引用成员变量
- 需要调用成员变量的构造函数
- 派生类需要调用基类的构造函数



**一个内联函数如果要在.h文件里面声明就必须也在里面定义**





### 值初始化

用T t{}默认初始化

