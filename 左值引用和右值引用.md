**左值：**

有持久存储地址，可以取地址，有名字(int x),**能出现在赋值号左边**

**右值：**

临时值，字面值（10），函数返回的临时对象

**左值引用:**

```c++
int x=10;
int&xx=x;
```

不能把左值引用绑定在临时量上

**但是左值常量引用可以绑定在临时量上，拓展它的生命周期**

```c++
int&x=10//这是错误的
const int&x=10;//这是正确的
```



**右值引用：**

```c++
int&&x=10;
```



但是，即使一个变量是 `T&&` 类型，**在函数体内部它仍然是一个“左值”**（因为它有名字）

```c++
void func(string&&s){
    string s1=s;//此时s1是对s的拷贝，s还会存在
    string s1=move(s);//此时就是将s的值直接给s1，s此时的状态是不确定的
}
```



**移动语义**

假设现在有一个字符串类

```c++
#include<iostream>
using namespace std;
class S{
private:
	char* ss;
	size_t size;
public:
	S(const char* add) {
		int len = strlen(add);
		ss = new char[len + 1];
		strcpy(ss, add);
	}//构造函数
	S(const S& x):size(x.size){
		ss = new char[size + 1];
		strcpy(ss, x.ss);
	}//拷贝构造函数
	S(S&& x):ss(x.ss),size(x.size) {
		x.ss = nullptr;
		x.size = 0;
	}//移动构造函数 此时x为右值
	S& operator = (const S & x){
		size = x.size;
		ss = new char[size + 1];
		strcpy(ss, x.ss);
		return *this;
	}//拷贝赋值
	S& operator=(S&& x) {
		if (&x != this) {
			delete[]ss;
			ss = x.ss;
			size = x.size;
			x.ss = nullptr;
			x.size = 0;
		}
		return *this;
	}//移动赋值
};
int main() {
	S a("abc");//调用构造函数
	S b = a;//拷贝构造函数
	S c = S("aaa");//移动构造函数
	b = c;//拷贝赋值
	b = move(c);//移动赋值
}
```



**move函数**

将一个左值强制转化为右值

**此时被转化的值处于有效但未指定状态**