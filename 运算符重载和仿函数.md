### 运算符重载

**运算符可以是成员函数也可以是非成员函数**



```c++
class A {
private:
	int x;
	int y;
public:
};
```



#### 赋值与复合赋值

**一元（成员函数）**

```c++
	A& operator=(const A& a) {
		if (this != &a) {
			x = a.x;
			y = a.y;
		}
		return *this;
	}//赋值
	A& operator=(A&& a) {
		if (this != &a) {
			x = a.x;
			y = a.y;
			a.x = 0;
			a.y = 0;
		}
        return *this;
	}//移动赋值
	A& operator+=(const A& x){}
	//还有 -= *= /= %= &= |= ^= <<= >>=
```



**二元（非成员的友元函数）(也可以写成成员函数）**

```c++
A operator+(const A& b)const {
	return A(x + b.x, y + b.y);
}//成员函数
friend A operator+(const A& a, const A& b);
A operator+(const A& a, const A& b) {
	return A(a.x + b.x, a.y + b.y);
}//友元的非成员函数
A operator+(const A & a, int val) {
	return A(a.x + val, a.y + val);
}//运算符重载也可以函数重载
```



**关系运算符**

```c++
friend bool operator==(const A& a, const A& b);
friend bool operator<(const A& a, const A& b);
bool operator==(const A& a, const A& b) {
	return a.x == b.x && a.y == b.y;
}
bool operator<(const A& a, const A& b) {
	return a.x < b.x ||( a.y == b.y&&a.y<b.y);
}
其他的> >= <=可以通过调用<和调用==来重载
 bool operator>(const A& a, const A& b) {
	return !(a<b||a==b);//或者b<a
}
```



**输入输出运算符**

```c++
	friend ostream& operator<<(ostream& os, const A& a) {
		return os << "x=" << a.x << ' ' << "y=" << a.y;
	}
	friend istream& operator>>(istream& is, A& a) {
		return is >> a.x >> a.y;
	}
```



**前置后置**

```c++
	A& operator++() {
		cout << "前置" << endl;
		x++; y++;
		return *this;
	}
	A operator++(int) {
		cout << "后置" << endl;
		A a = *(this);
		x++, y++;
		return a;
	}
```



**下标运算符**

```c++
	int& operator[](int id) {
		return a[id];
	}//调用非常量对象
	const int& operator[](int id)const {
		return a[id];
	}//常量对象
```



**new和delete运算符重载**

```c++
void* operator new(size_t siz) {
	void* p = malloc(siz);
	return p;
}
void operator delete(void* p)noexcept {
	free(p);
}
void* operator new[](size_t siz) {
	void* p = malloc(siz);
	return p;
}
void operator delete[](void*p) {
	free(p);
}
```

参数的内容已经固定了不能改

noexcept意思是这个函数保证不会抛出异常如果抛出异常那么程序就直接终止了

### 仿函数

c++任何类只要重载了operator()()，这个类的对象就可以像函数一样调用

```c++
struct add {
	int operator()(int a, int b) {
		return a + b;
	}
};
int main() {
	add a;
	cout << a(1, 2);
}
```



**仿函数比起普通函数的优点**

函数不能有持久化状态但是对象可以有

```c++
struct f {
	int cnt = 0;
	void operator()() {
		cnt++;
	}
};
int main() {
	f a;
	a(); a(); a();
	cout << a.cnt;
}
```



#### 仿函数常用场景

**1 sort 自定义比较器**

```c++
struct Cmp {
    bool operator()(int a, int b) const {
        return a > b; // 降序
    }
};

vector<int> v = {3, 1, 4};
sort(v.begin(), v.end(), Cmp());
```

你给 `sort()` 传递的是一个对象（Cmp()），完全等价于：

```c++
bool cmp(int a, int b);
```



**2 priority_queue 自定义优先级**

```c++
priority_queue<int, vector<int>, Cmp> pq;
```

Cmp 必须是仿函数（或者函数指针），因为 STL 需要“可调用对象”。

**3 unordered_map 自定义哈希函数**

```c++
struct PairHash {
    size_t operator()(const pair<int,int>& p) const {
        return p.first * 1315423911U + p.second;
    }
};

unordered_map<pair<int,int>, int, PairHash> mp;
unordered_set<pair<int,int>,PairHash>se;
```

这里 PairHash 就是个仿函数。
